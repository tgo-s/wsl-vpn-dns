#!/usr/bin/env bash
set -euo pipefail

# smart-resolv.sh
# Gather currently active nameservers and replace /etc/resolv.conf with a clean list.
# Tries in order: systemd-resolved (resolvectl), NetworkManager (nmcli), /run/systemd/resolve/resolv.conf,
# and finally parses existing /etc/resolv.conf for currently reachable nameservers.

OUTFILE="/tmp/resolv.conf.smart"
BACKUP="/etc/resolv.conf.bak.$(date +%s)"
TMPFILE=$(mktemp)

# CLI flags
DRY_RUN=0
DEST="/etc/resolv.conf"

usage(){
  cat <<EOF
Usage: $0 [--stdout|--dry-run] [--dest <file>]
  --stdout, --dry-run   Print the generated resolv.conf to stdout instead of writing it
  --dest <file>         Destination file to write (default: /etc/resolv.conf)
  If writing to protected locations, the script will try to use sudo.
EOF
  exit 1
}

while [[ ${#} -gt 0 ]]; do
  case "$1" in
    --stdout|--dry-run|-n)
      DRY_RUN=1; shift;;
    --dest)
      DEST="$2"; shift 2;;
    -h|--help)
      usage;;
    *)
      eprintf "Unknown arg: $1"; usage;;
  esac
done

# If there is data on stdin (piped extra nameservers), read and add them.
# Accept lines like: 1.2.3.4 or "nameserver 1.2.3.4" or CRLF-terminated.
if [ ! -t 0 ]; then
  while IFS= read -r line; do
    # strip windows CR
    line=${line%$'\r'}
    # extract IPv4 or IPv6 between words
    if [[ $line =~ ([0-9A-Fa-f:.]+) ]]; then
      add_ns "${BASH_REMATCH[1]}"
    fi
  done < /dev/stdin
fi

# Helper: print to stderr
eprintf(){ printf "%s\n" "$*" >&2; }

# Collect nameservers in an ordered, unique way
declare -a ns_list
add_ns(){
  local ip="$1"
  for e in "${ns_list[@]:-}"; do
    [[ "$e" == "$ip" ]] && return
  done
  ns_list+=("$ip")
}

# 1) systemd-resolved via resolvectl
if command -v resolvectl >/dev/null 2>&1; then
  while read -r line; do
    # lines like: DNS Servers: 8.8.8.8
    if [[ $line =~ ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+) ]]; then
      add_ns "${BASH_REMATCH[1]}"
    fi
  done < <(resolvectl status 2>/dev/null | sed -n '/DNS Servers:/,$p' )
fi

# 2) NetworkManager via nmcli
if [[ ${#ns_list[@]} -eq 0 ]] && command -v nmcli >/dev/null 2>&1; then
  # nmcli device show lists IP4.DNS entries per active connection
  while read -r ip; do
    [[ -n "$ip" ]] && add_ns "$ip"
  done < <(nmcli -t -f IP4.DNS device show | sed '/^$/d' | tr ':' '\n' | sed '/^$/d')
fi

# 3) systemd-resolved file
if [[ ${#ns_list[@]} -eq 0 && -f /run/systemd/resolve/resolv.conf ]]; then
  while read -r ip; do
    add_ns "$ip"
  done < <(grep -E '^nameserver' /run/systemd/resolve/resolv.conf | awk '{print $2}')
fi

# 4) Fallback: parse /etc/resolv.conf but only include servers that respond to a quick DNS query
if [[ ${#ns_list[@]} -eq 0 && -f /etc/resolv.conf ]]; then
  while read -r ip; do
    add_ns "$ip"
  done < <(grep -E '^nameserver' /etc/resolv.conf | awk '{print $2}')
fi

# If still empty, add public defaults
if [[ ${#ns_list[@]} -eq 0 ]]; then
  add_ns 8.8.8.8
  add_ns 1.1.1.1
fi

# Write to temp and atomically move into place (leave backup)
{
  printf "# Generated by smart-resolv.sh at %s\n" "$(date -Iseconds)"
  for ip in "${ns_list[@]}"; do
    printf "nameserver %s\n" "$ip"
  done
} > "$TMPFILE"

# Make a backup of /etc/resolv.conf if it's a regular file or symlink we will replace
eprintf "wrote /etc/resolv.conf (backup: $BACKUP)\n"
if [[ $DRY_RUN -eq 1 ]]; then
  # Print to stdout and exit
  cat "$TMPFILE"
  rm -f "$TMPFILE"
  exit 0
fi

# We're going to write to $DEST. Make a backup of the existing destination if present
if [[ -e "$DEST" ]]; then
  # Only attempt to backup the actual file
  if cp -a "$DEST" "$BACKUP" 2>/dev/null; then
    :
  else
    eprintf "warning: couldn't backup $DEST (permission denied?)"
  fi
fi

# If DEST is a symlink, get its resolved target for special handling
if [[ -L "$DEST" ]]; then
  target=$(readlink -f "$DEST")
else
  target="$DEST"
fi

# If the target appears to be systemd-resolved's file, warn and attempt to write there
if [[ $target == /run/systemd/resolve/stub-resolv.conf ]] || [[ $target == /run/systemd/resolve/resolv.conf ]]; then
  eprintf "$DEST is managed by systemd-resolved (target: $target). Will attempt to update the target."
fi

# Try to write the TMPFILE into target; prefer direct copy if writable, otherwise use sudo cp
if cp "$TMPFILE" "$target" 2>/dev/null; then
  :
elif [[ $(id -u) -eq 0 ]]; then
  # running as root but cp failed for some reason
  cp "$TMPFILE" "$target" || eprintf "failed to write $target"
elif command -v sudo >/dev/null 2>&1; then
  sudo cp "$TMPFILE" "$target" || eprintf "sudo failed to write $target"
else
  eprintf "no permission to write $target and sudo not available; printing file to stdout instead"
  cat "$TMPFILE"
  rm -f "$TMPFILE"
  exit 1
fi

rm -f "$TMPFILE"

eprintf "wrote $target (backup: $BACKUP)\n"
exit 0
